
## 遇到过的技术问题？ 怎么解决的

>-	这个问题很常见，有没有遇到过很不常见的问题？比如在网上根本搜不到解决方法的


##什么是 Cookie？
	Cookie 是一些数据, 存储于你电脑上的文本文件中。
	当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。
	Cookie 的作用就是用于解决 "如何记录客户端的用户信息":

W3C : [什么是cookie](http://www.runoob.com/js/js-cookies.html)

## 请你谈谈Cookie的弊端
>-	a. 每个特定的域名下最多生成的cookie个数有限制
>-	b. IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie
>-	c. cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节
>-	d. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息

##设置 cookie 值的函数

```
function setCookie(cname,cvalue,exdays)
{
	  var d = new Date();
	  d.setTime(d.getTime()+(exdays*24*60*60*1000));
	  var expires = "expires="+d.toGMTString();
	  document.cookie = cname + "=" + cvalue + "; " + expires;
}
```
函数解析：
以上的函数参数中，cookie 的名称为 cname，cookie 的值为 cvalue，并设置了 cookie 的过期时间 expires。
该函数设置了 cookie 名、cookie 值、cookie过期时间。

##获取 cookie 值的函数

```
function getCookie(cname)
{
	  var name = cname + "=";
	  var ca = document.cookie.split(';');
	  for(var i=0; i<ca.length; i++)
	  {
	    var c = ca[i].trim();
	    if (c.indexOf(name)==0) return c.substring(name.length,c.length);
	  }
	  return "";
}
```
```
函数解析：
cookie 名的参数为 cname。
创建一个文本变量用于检索指定 cookie :cname + "="。
使用分号来分割 document.cookie 字符串，并将分割后的字符串数组赋值给 ca (ca = document.cookie.split(';'))。
循环 ca 数组 (i=0;i<ca.length;i++)，然后读取数组中的每个值，并去除前后空格 (c=ca[i].trim())。
如果找到 cookie(c.indexOf(name) == 0)，返回 cookie 的值 (c.substring(name.length,c.length)。
如果没有找到 cookie, 返回 ""。
```

##完整实例
```
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toGMTString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
}

function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i].trim();
        if (c.indexOf(name) == 0) {
            return c.substring(name.length, c.length);
        }
    }
    return "";
}

function checkCookie() {
    var user = getCookie("username");
    if (user != "") {
        alert("欢迎 " + user + " 再次访问");
    } else {
        user = prompt("请输入你的名字:", "");
        if (user != "" && user != null) {
            setCookie("username", user, 30);
        }
    }
}
```



##请描述一下 cookies，sessionStorage 和 localStorage 的区别？

>-  cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会
>-  sessionStorage和localStorage的存储空间更大；
>-  sessionStorage和localStorage有更多丰富易用的接口；
>-  sessionStorage和localStorage各自独立的存储空间
>-  CSDN: [3分钟学会sessionStorage用法](http://blog.csdn.net/oaa608868/article/details/53539954)
>-  [浅谈session,cookie,sessionStorage,localStorage的区别及应用场景](https://www.cnblogs.com/cencenyue/p/7604651.html)

##ajax请求的时候get 和post方式的区别?

>- 一个在url后面 一个放在虚拟载体里面
>- 有大小限制
>- 安全问题
>- 应用不同 一个是论坛等只需要请求的，一个是类似修改密码的;


##call和apply的区别


>- call和apply的功能基本相同，都是实现继承或者转换对象指针的作用；
>- 唯一不通的是前者参数是罗列出来的，后者是存到数组中的；
>- call或apply功能就是实现继承的；与面向对象的继承extends功能相似；但写法不同；
>- Object.call(this,obj1,obj2,obj3)
>- Object.apply(this,arguments)
>- .call(对象[,参数1，参数2,....]);//此地参数是指的是对象的参数，非方法的参数；
>- .apply(对象,参数数组)//参数数组的形式:[参数1，参数2,......]


##表述您对javascript this工作原理的理解

>-	全局范围内:	当在全部范围内使用 this，它将会指向全局对象。浏览器中运行的 JavaScript 脚本，这个全局对象是 window。
>-	函数调用:	这里 this 也会指向全局对象。
				ES5 注意: 在严格模式下（strict mode），不存在全局变量。 这种情况下 this 将会是 undefined。
>-	方法调用:	test.foo();	这个例子中，this 指向 test 对象。
>-	调用构造函数:		new foo();	如果函数倾向于和 new 关键词一块使用，则我们称这个函数是 构造函数。 在函数内部，this 指向新创建的对象。

>-	显式的设置 this
```
function foo(a, b, c) {
	this.name = a;
}

var bar = {};
foo.apply(bar, [1, 2, 3]); // 数组将会被扩展，如下所示
foo.call(bar, 1, 2, 3); // 传递到foo的参数是：a = 1, b = 2, c = 3

var boundFunc = foo.bind(bar);
```

##bind 与call、apply的差别

call、apply是改动函数的作用域，而且马上运行。而bind是返回了一个新的函数，不是马上运行，
即call and apply call a function while bind creates a function。
bind在回调函数中经常使用到。


##闭包是什么，有什么特性，对页面有什么影响?简要介绍你理解的闭包

>- 闭包就是能够读取其他函数内部变量的函数。
>- 常用-- 用途

## 事件委托是什么

>- 让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！

>- 实现？？

## 如何阻止事件冒泡和默认事件

```
function stopBubble(e)
{
    if (e && e.stopPropagation)
        e.stopPropagation()
    else
        window.event.cancelBubble=true
}
return false;
```


## 编写一个b继承a的方法;
```
// 定义一个动物类
function Animal(name) {
    // 属性
    this.name = name || 'Animal';
    // 实例方法
    this.sleep = function() {
        console.log(this.name + '正在睡觉！');
    }
}
// 原型方法
Animal.prototype.eat = function(food) {
    console.log(this.name + '正在吃：' + food);
};

//组合继承
//核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用

function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}

Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;


// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true

```

## 下面程序执行后弹出什么样的结果?

```
function fn() {
    this.a = 0;
    this.b = function() {
        alert(this.a)
    }
}
fn.prototype = {
    b: function() {
        this.a = 20;
        alert(this.a);
    },
    c: function() {
        this.a = 30;
        alert(this.a);
    }
}
var myfn = new fn();
myfn.b();			//	 0 		-- 现在构造函数中查找， 找不到 才会  到 prototype 中查找
myfn.c();			// 	30
```

## js中的new xx()到底做了些什么？？

>-	1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
>-	2、属性和方法被加入到 this 引用的对象中。
>-	3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
>-	[JS 的 new 到底是干什么的？](http://web.jobbole.com/91017/)
>-	送上权威文档[飞机票](https://segmentfault.com/q/1010000006670906?_ea=1091798)


## 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）

>-	[飞机票](https://www.jianshu.com/p/71cf7f69eca8)

>-	1.在浏览器地址栏输入URL
>-	2.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤

>-    i. 如果资源未缓存，发起新请求
>-    ii. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
>-    iii. 检验新鲜通常有两个HTTP头进行控制 Expires 和 Cache-Control ：

>-      HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
>-      HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间

>-	3.浏览器解析URL获取协议，主机，端口，path
>-	4.浏览器组装一个HTTP（GET）请求报文
>-	5.浏览器获取主机ip地址，过程如下：

>-      i. 浏览器缓存
>-      ii. 本机缓存
>-      iii. hosts文件
>-      iv. 路由器缓存
>-      v. ISP DNS缓存
>-      vi. DNS递归查询（可能存在负载均衡导致每次IP不一样）
>-  6.打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：
>-      i. 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口
>-      ii. 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
>-      iii. 客户端发送ACK=Y+1， Seq=Z
>- 7. TCP链接建立后发送HTTP请求
>- 8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程
序
>- 9. 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码
>- 10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
>- 11. 服务器将响应报文通过TCP连接发送回浏览器
>- 12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：
>-     i. 主动方发送Fin=1， Ack=Z， Seq= X报文
>-     ii. 被动方发送ACK=X+1， Seq=Z报文
>-     iii. 被动方发送Fin=1， ACK=X， Seq=Y报文
>-     iv. 主动方发送ACK=Y， Seq=X报文
>- 13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
>- 14. 如果资源可缓存，进行缓存
>- 15. 对响应进行解码（例如gzip压缩）
>- 16. 根据资源类型决定如何处理（假设资源为HTML文档）
>- 17. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺

>- 18. 构建DOM树：
    i. Tokenizing：根据HTML规范将字符流解析为标记
    ii. Lexing：词法分析将标记转换为对象并定义属性和规则
    iii. DOM construction：根据HTML标记关系将对象组成DOM树
>- 19. 解析过程中遇到图片、样式表、js文件，启动下载
>- 20. 构建CSSOM树：
>-    i. Tokenizing：字符流转换为标记流
>-    ii. Node：根据标记创建节点
>-    iii. CSSOM：节点创建CSSOM树
>-  21. 根据DOM树和CSSOM树构建渲染树:
>-    i. 从DOM树的根节点遍历所有可见节点，不可见节点包括：1） script , meta 这样本身不可见的标
>-    签。2)被css隐藏的节点，如 display: none
>-    ii. 对每一个可见节点，找到恰当的CSSOM规则并应用
>-    iii. 发布可视节点的内容和计算样式
>- 22. js解析如下：
>-    i. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时
    document.readystate为loading
>-    ii. HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚
>-    本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用
>-    document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们
>-    可以遍历和操作script和他们之前的文档内容
>-    iii. 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成
>-    后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以
>-    访问自己script和之前的文档元素
>-    iv. 当文档完成解析，document.readState变成interactive
>-    v. 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()
>-    vi. 浏览器在Document对象上触发DOMContentLoaded事件
>-    vii. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件
>-  23. 显示页面（HTML解析过程中会逐步显示页面）

## 闭包的概念
>-	阮一峰：[飞机票](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
>-	链式作用域
	全局作用域
	局部作用域

	就在于函数内部可以直接读取全局变量。
	在函数外部自然无法读取函数内的局部变量。

>-	闭包就是能够读取其他函数内部变量的函数。

>-	另一个就是让这些变量的值始终保持在内存中。


##你对 HTTP 的状态吗了解多少...

1XX: 一般用来判断协议更换或者确认服务端收到请求这些

    100: 服务端收到部分请求,若是没有拒绝的情况下可以继续传递后续内容
    101: 客户端请求变换协议,服务端收到确认

2xx: 请求成功,是否创建链接,请求是否接受,是否有内容这些

    200: 请求成功
    201: 请求创建成功和资源创建成功

3XX: 一般用来判断重定向和缓存

    301: 所有请求已经转移到新的 url(永久重定向),会被缓存
    302: 临时重定向,不会被缓存
    304: 本地资源暂未改动,优先使用本地的(根据If-Modified-Since or If-Match去比对服务器的资源,缓存)


4XX: 一般用来确认授权信息,请求是否出错,页面是否丢失

    400: 请求出错
    401: 未授权,不能读取某些资源
    403: 阻止访问,一般也是权限问题
    404: 页面丢失,资源没找到
    408: 请求超时
    415: 媒介类型不被支持，服务器不会接受请求。


5XX: 基本都是服务端的错误

    500: 服务端错误
    502: 网关错误
    504: 网关超时


##你对优化这块了解多少?

比如从客户端着手的:

    压缩代码(JS/CSS),压缩图片
    合并一些小图片(css sprite)
    若是打包的代码尽可能切割成多个 chunk,减少单一 chunk过大
    静态文件采用 cdn 引入
    HTTP的缓存头使用的合理
    减小第三方库的依赖
    对于代码应该考虑性能来编写,比如使用requestAnimationFrame绘制动画,尽可能减少页面重绘(DOM 改变)
    渐进升级,引入preload这些预加载资源
    看情况用server worker来缓存资源(比如移动端打算搞 PWA)
比如从服务端着手:

    带宽,域名解析, 多域名解析等
    页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)
    渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)




    